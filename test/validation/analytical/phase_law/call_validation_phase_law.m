%% VALIDATION PHASE LAWS

abram_install()

% Compare the power entering the pupil generated by a lambertian textureless sphere 
% at zero phase angle at very far distance using phase laws with the one generated by ABRAM.

% Phase law model
%   Ir = phase_law*I0 = phase_law*Rbody^2*F*pGeom 
%      = phase_law*Rbody^2*pGeom*pi*Rlight^2/d_body2light^2*Lstar
%   P = Ir*OM = Ir*Apupil/(d_body2cam)^2
%   G = phase_law*Rbody^2*pGeom*pi*Rlight^2/d_body2light^2*Apupil/(d_body2cam)^2 = 
%      = pi*phase_law*pGeom*(Rbody*Rlight/(d_body2light*d_body2cam))^2*Apupil
%
% We should see the difference between the two models going towards
% zero as the distance increases.This because the different d_body2cam
% converges towards the same and the integral approximates the full sphere

%% Inputs
d_body2cam_vec = logspace(8, 12, 20);  % [m]
filename_yml = 'validation_phase_law.yml';
rend = abram.render(filename_yml, false);

rend.body.radiometry.model = 'lambert'
rend.scene.phase_angle = pi/3
rend.setting.discretization.method = 'fixed';
rend.setting.discretization.np = 4e5;
% rend.setting.discretization.method = 'adaptive';
% rend.setting.discretization.accuracy = 10;
rend.setting.integration.method = 'trapz';
rend.setting.reconstruction.granularity = 1;

% Extract data
phase_angle = rend.scene.phase_angle;
model = rend.body.radiometry.model;
Rbody = rend.body.radius;
Rlight = rend.light.radius;
d_body2light = rend.scene.d_body2light;
Apupil = rend.camera.Apupil;
res_px = rend.camera.res_px;

%% ABRAM
% Loop

for ix = 1:length(d_body2cam_vec)
    
    % Set distance
    rend.scene.d_body2cam = d_body2cam_vec(ix);

    % Rendering
    rend = rend.rendering();

    % Image
    Gref(ix) = rend.matrix.adim;
    G(ix) = sum(rend.matrix.values(rend.matrix.ixsValid))*Gref(ix);
end

%% Analytical model
switch model
    case 'lambert'
        phase_law = @(alpha) abram.brdf.lambertPhase(alpha);
        pGeom = rend.body.pGeom;

    case 'lommel'
        phase_law = @(alpha) abram.brdf.lommelPhase(alpha);
        pGeom = rend.body.pGeom;

    case 'area'
        phase_law = @(alpha) abram.brdf.areaPhase(alpha);
        pGeom = rend.body.pGeom;

    case 'hapke'
        radiometry_parameters = num2cell(rend.body.radiometry.parameters);
        phase_law = @(alpha) abram.brdf.hapkePhase(phase_angle, rend.body.albedo, radiometry_parameters{:});
        pGeom = abram.brdf.hapkeAlbedo(rend.body.albedo, radiometry_parameters{:});
end

Astar = pi*Rlight^2;
Gcomp = phase_law(phase_angle)*pGeom*(Rbody./(d_body2light*d_body2cam_vec)).^2*Apupil*Astar;
d_body2cam_inv = sqrt(pi*phase_law(phase_angle)*pGeom*(Rbody*Rlight./d_body2light).^2*Apupil ./ G);
modelDiff = d_body2cam_vec - d_body2cam_inv;

phase_law_comp = G./(pGeom*(Rbody./(d_body2light*d_body2cam_vec)).^2*Apupil*Astar);

%% POST-PRO
postpro_validation_phase_law()