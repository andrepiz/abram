%% VALIDATION PHASE LAWS

abram_install()

% Compare the power entering the pupil generated by a lambertian textureless sphere 
% at zero phase angle at very far distance using phase laws with the one generated by ABRAM.

% Phase law model
%   Ir = phase_law*I0 = phase_law*Rbody^2*F*pGeom 
%      = phase_law*Rbody^2*pGeom*pi*Rstar^2/d_body2light^2*Lstar
%   P = Ir*OM = Ir*Apupil/(d_body2cam)^2
%   G = phase_law*Rbody^2*pGeom*pi*Rstar^2/d_body2light^2*Apupil/(d_body2cam)^2 = 
%      = pi*phase_law*pGeom*(Rbody*Rstar/(d_body2light*d_body2cam))^2*Apupil
%
% We should see the difference between the two models going towards
% zero as the distance increases.This because the different d_body2cam
% converges towards the same and the integral approximates the full sphere

%% Inputs
d_body2cam_vec = logspace(8, 12, 20);  % [m]
filename_yml = 'mars_no_texture_zero_phase_far.yml';
rend = abram.render(filename_yml);

rend.body.radiometry.model = 'lambert'
rend.scene.phase_angle = pi/3
% rend.setting.discretization.method = 'fixed';
% rend.setting.discretization.np = 1e6;
rend.setting.discretization.method = 'adaptive';
rend.setting.discretization.accuracy = 10;
rend.setting.integration.method = 'trapz';

% Extract data
phase_angle = rend.scene.phase_angle;
model = rend.body.radiometry.model;
pGeom = rend.body.pGeom;
Rbody = rend.body.radius;
Rstar = rend.light.radius;
d_body2light = rend.scene.d_body2light;
Apupil = rend.camera.Apupil;
res_px = rend.camera.res_px;

%% ABRAM
% Loop
rend = rend.getParPool(); 
rend = rend.loadMaps(); 
rend = rend.setSpectrum();

for ix = 1:length(d_body2cam_vec)
    
    % Set distance
    rend.scene.d_body2cam = d_body2cam_vec(ix);

    % Rendering
    rend = rend.rendering();

    % Image
    Gref(ix) = rend.matrix.adim;
    G(ix) = sum(rend.matrix.values(rend.matrix.ixsValid))*Gref(ix);
end

%% Analytical model
switch model
    case 'lambert'
        phase_law =  @(alpha) 1/pi*((pi-alpha)*cos(alpha) + sin(alpha));

    case 'lommel'
        phase_law = @(alpha) 1 + sin(alpha/2)*tan(alpha/2)*log(tan(alpha/4));

    case 'area'
        phase_law = @(alpha) 1/2*(1 + cos(alpha));

    case 'hg'
        phase_law = @(alpha) nan;
end
Astar = pi*Rstar^2;
Gcomp = phase_law(phase_angle)*pGeom*(Rbody./(d_body2light*d_body2cam_vec)).^2*Apupil*Astar;
d_body2cam_inv = sqrt(pi*phase_law(phase_angle)*pGeom*(Rbody*Rstar./d_body2light).^2*Apupil ./ G);
modelDiff = d_body2cam_vec - d_body2cam_inv;

phase_law_comp = G./(pGeom*(Rbody./(d_body2light*d_body2cam_vec)).^2*Apupil*Astar);

%%
postpro_validation_phase_law