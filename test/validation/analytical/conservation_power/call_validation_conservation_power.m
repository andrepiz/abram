%% VALIDATION CONSERVATION POWER
% Compare the power entering the pupil generated by a lambertian textureless sphere 
% at zero phase angle using an analytical model against the power generated by ABRAM.

% The incident angle of the normal wrt sun on a sphere at 0 phase angle: 
%   delta_i = atan((d_cam2inter.*sin(alpha))/(d_cam2body - d_cam2inter.*cos(alpha))
% Where d_cam2inter is the distance of the intersection point of the ray from
% the pupil entrance and alpha the LOS of the pixel
% Defining alpha as the LOS direction of the pixel, the reflection angle
% wrt normal is:
%   delta_r = delta_i + alpha
%
% Reflected radiance [W/(sr m^2)]:
%   L = BRDF * E = pBond/pi * F * cos(delta_i) = 
%     = pBond/pi * pi * Rsun^2/d_body2sun^2 * Lstar * cos(delta_i)
%
% By equivalence of radiance (in and out of pupil):
%   Lin = Lout = L
%   Iin / (Apx * cos(alpha)) = Iout / (Asph * cos(delta_r)) = L
% Where Apx is the area of a pixel and Asph is the area that the projection
% of a pixel on the sphere covers.
%
% Collected power [W]:
%   P = Iin * OMin = L * Apx * cos(alpha) * OMin
% Where the internal projected spherical angle is:
%   OMin = Apupil * cos(alpha) / rin^2 = Apupil / (f/(cos(alpha))^3
%
% For a final expression of: 
%   P = pBond/pi * Rstar^2/d_body2star^2 * Lstar * cos(delta_i) * Apx * cos(alpha) * Apupil /(f/(cos(alpha))^3 = 
%     = pBond * Rstar^2/d_body2star^2 * Lstar * cos(delta_i) * Apx * cos(alpha)^4 * Apupil / f^2
% 
% Note that instead in ABRAM the power is computed as:
%   P = Iout * OMout = L * Asph * cos(delta_r) * Apupil * cos(offpoint) / rout^2 = 
%     = pBond * Rstar^2/d_body2star^2 * Lstar * cos(delta_i) * Asph * cos(delta_r) * Apupil * cos(offpoint) / r_sphere^2
%
abram_install()

%% ABRAM rendering
filename_yml = 'sphere_zero_phase.yml'; % must be wide angle, full FOV covering example!

inputs_yml();

run_model();

%% Power expected from analytical model

% for each pixel, we want to compute the angle between the pinhole and the
% sector (or between the pinhole and the pixel).
px_x = 1:res_px(1);
px_y = 1:res_px(2);
px_cx = res_px(1)/2;
px_cy = res_px(2)/2;
px_r = sqrt((px_x - px_cx).^2 + (px_y' - px_cy).^2);
alpha_bs = atan(px_r*muPixel(1)/f);
% d_cam2inter = d_body2cam*cos(alpha_bs) - sqrt(Rbody^2 - d_body2cam^2.*sin(alpha_bs));
% d_cam2inter(imag(d_cam2inter) ~= 0) = nan;
d_cam2inter = zeros(res_px(1), res_px(2));
for ix_x = px_x
    for ix_y = px_y
        P1 = [muPixel(1)*(px_x(ix_x) - px_cx); muPixel(2)*(px_y(ix_y) - px_cy); 0];
        d_cam2inter(ix_x, ix_y) = norm(intersect_line_sphere(P1, [0; 0; f], [0; 0; d_body2cam], Rbody));
    end
end
delta_i = atan((d_cam2inter.*sin(alpha_bs))./(d_body2cam - d_cam2inter.*cos(alpha_bs))); % only for 0 phase angle!
Apx = muPixel(1)*muPixel(2);
P_bw_comp = pBond * Apx * cos(alpha_bs).^4.*Apupil/(f^2)...
    .*cos(delta_i).*(Rstar/d_body2star)^2.*L_bw;

%% Power computed by ABRAM
PL_pixel = matrix.values.*matrix.adim;
P_bw = PL_pixel.*L_bw;
P_bw(P_bw == 0) = nan;

%% Post-pro
postpro_validation_conservation_power